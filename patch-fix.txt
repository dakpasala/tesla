Paste the file onto root node_modules/@gorhom/bottom-sheet/src/hooks/useBoundingClientRect.ts

NOTE: after upgrading to 5.2.8 gorhom and reanimted 4 and fixing worklets issue, I no longer needed this
- definitely double check that things still build well on ios and if use bounding breaks this patch should fix it

INSTRUCTIONS TO MAKE PERSISTENT:
yarn add -D patch-package (at root)
edit the file as discussed
npx patch-package @gorhom/bottom-sheet

add patch package to post install scripts

"scripts": {
  "postinstall": "patch-package",
  ...
}

commit the patches folder
Now patch will be applied after each yarn install

import { type RefObject, useLayoutEffect } from 'react';
import type { View } from 'react-native';
import { isFabricInstalled } from '../utilities/isFabricInstalled';

export type BoundingClientRect = {
  x: number;
  y: number;
  width: number;
  height: number;
  left: number;
  right: number;
  top: number;
  bottom: number;
};

/**
 * A custom hook that retrieves the bounding client rectangle of a given `ref` element
 * and invokes a handler function with the layout information.
 *
 * This hook is designed to work with React Native's Fabric architecture and provides
 * support for both `unstable_getBoundingClientRect` and `getBoundingClientRect` methods.
 *
 * @param ref - A `RefObject` pointing to a `View` or `null`. The bounding client rectangle
 *              will be retrieved from this reference.
 * @param handler - A callback function that will be invoked with the layout information
 *                  of the referenced element.
 *
 * @remarks
 * - The hook uses `useLayoutEffect` to ensure the layout information is retrieved
 *   after the DOM updates.
 * - The `isFabricInstalled` function is used to determine if the Fabric architecture
 *   is available.
 * - The `unstable_getBoundingClientRect` method is used if available, falling back
 *   to `getBoundingClientRect` otherwise.
 *
 * @example
 * ```tsx
 * const ref = useRef<View | null>(null);
 * useBoundingClientRect(ref, (layout) => {
 *   console.log('Bounding client rect:', layout);
 * });
 * ```
 */
export function useBoundingClientRect(
  ref: RefObject<View | null>,
  handler: (layout: BoundingClientRect) => void
) {
  if (!isFabricInstalled()) {
    return;
  }

  // biome-ignore lint/correctness/useHookAtTopLevel: `isFabricInstalled` is a constant that will not change during the runtime
  useLayoutEffect(() => {
    if (!ref || !ref.current) {
      return;
    }

    // Try unstable_getBoundingClientRect first
    if (
      // @ts-expect-error
      typeof ref.current.unstable_getBoundingClientRect === 'function'
    ) {
      // @ts-expect-error
      const layout = ref.current.unstable_getBoundingClientRect();
      handler(layout);
      return;
    }

    // Try getBoundingClientRect
    // @ts-expect-error
    if (typeof ref.current.getBoundingClientRect === 'function') {
      // @ts-expect-error
      const layout = ref.current.getBoundingClientRect();
      handler(layout);
      return;
    }

    // Fallback to measure() for RN 0.82+ compatibility
    // @ts-expect-error
    if (typeof ref.current.measure === 'function') {
      // @ts-expect-error
      ref.current.measure((x, y, width, height, pageX, pageY) => {
        handler({
          x: pageX,
          y: pageY,
          width,
          height,
          left: pageX,
          right: pageX + width,
          top: pageY,
          bottom: pageY + height,
        });
      });
    }
  });
}
